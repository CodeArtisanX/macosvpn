import Darwin
import SystemConfiguration

open class VPNServiceConfig {
  public enum Kind: String {
    case L2TPOverIPSec
    case CiscoIPSec
    case Unknown
  }

  public init(kind: Kind, name: String, endpoint: String) {
    self.kind = kind
    self.name = name
    self.endpoint = endpoint
  }

  public var kind: Kind

  // Assigned on-the-fly once generated by the OS
  public var serviceID: String?
  
  // Both L2TP and Cisco
  public var name: String
  public var endpoint: String
  
  public var username: String?
  public var password: String?
  public var sharedSecret: String?
  public var localIdentifier: String?
  
  // L2TP-specific
  public var enableSplitTunnel: Bool = false
  public var disconnectOnSwitch: Bool = false
  public var disconnectOnLogout: Bool = false
  
  public var humanKind: String {
    switch kind {
    case .L2TPOverIPSec: return "L2TP"
    case .CiscoIPSec: return "Cisco"
    default:
      return "Unknown"
    }
  }

  public var description: String {
    "<[VPNServiceConfig] name=\(name) endpoint=\(endpoint) username=\(String(describing: username)) password=\(String(describing: password)) sharedSecret=\(String(describing: sharedSecret)) localIdentifier=\(String(describing: localIdentifier))>"
  }
  
  public var l2TPPPPConfig: CFDictionary {
    var keys: [CFString?] = [nil, nil, nil, nil, nil, nil]
    var vals: [CFString?] = [nil, nil, nil, nil, nil, nil]
    var count = CFIndex(0)
    
    keys[count] = kSCPropNetPPPCommRemoteAddress
    vals[count] = endpoint as CFString?
    count += 1
    
    keys[count] = kSCPropNetPPPAuthName
    vals[count] = username as CFString?
    count += 1
    
    keys[count] = kSCPropNetPPPAuthPassword
    vals[count] = serviceID as CFString?
    count += 1
    
    keys[count] = kSCPropNetPPPAuthPasswordEncryption
    vals[count] = kSCValNetPPPAuthPasswordEncryptionKeychain
    count += 1
    
    let switchOne = disconnectOnSwitch ? "1" : "0"
    keys[count] = kSCPropNetPPPDisconnectOnFastUserSwitch
    // CFNumber is the correct type I think, as you can verify in the resulting /Library/Preferences/SystemConfiguration/preferences.plist file.
    // However, the documentation says CFString, so I'm not sure whom to believe.
    // See https://developer.apple.com/documentation/systemconfiguration/kscpropnetpppdisconnectonfastuserswitch
    // See also https://developer.apple.com/library/prerelease/ios/documentation/CoreFoundation/Conceptual/CFPropertyLists/Articles/Numbers.html
    // vals[count] = (CFNumberCreate(nil, CFNumberType.intType, &switchOne) as! CFString)
    vals[count] = switchOne as CFString?
    count += 1
    
    let logoutOne = disconnectOnLogout ? "1" : "0"
    keys[count] = kSCPropNetPPPDisconnectOnLogout
    // Again, not sure if CFString or CFNumber is more valid
    // vals[count] = (CFNumberCreate(nil, CFNumberType.intType, &logoutOne) as! CFString)
    vals[count] = logoutOne as CFString?
    count += 1
    
    return [
      keys,
      vals,
      count,
      kCFTypeDictionaryKeyCallBacks,
      kCFTypeDictionaryValueCallBacks
      ] as! CFDictionary
  }
  
  public var l2TPIPSecConfig: CFDictionary {
    var size: Int
    if localIdentifier == nil {
      size = 3
    } else {
      size = 5
    }

    var keys: [CFString?] = Array(repeating: nil, count: size)
    var vals: [CFString?] = Array(repeating: nil, count: size)
    var count = CFIndex(0)

    keys[count] = kSCPropNetIPSecAuthenticationMethod
    vals[count] = kSCValNetIPSecAuthenticationMethodSharedSecret
    count += 1

    keys[count] = kSCPropNetIPSecSharedSecretEncryption
    vals[count] = kSCValNetIPSecSharedSecretEncryptionKeychain
    count += 1

    guard let unwrappedServiceID = serviceID else {
      Log.error("Could not unwrap the ServiceID")
      exit(999)
    }

    keys[count] = kSCPropNetIPSecSharedSecret
    vals[count] = "\(unwrappedServiceID).SS" as CFString?
    count += 1

    if (localIdentifier) != nil {
      Log.debug("Assigning group name \(String(describing: localIdentifier)) to L2TP service config")

      keys[count] = kSCPropNetIPSecLocalIdentifier
      vals[count] = localIdentifier as CFString?
      count += 1

      keys[count] = kSCPropNetIPSecLocalIdentifierType
      vals[count] = kSCValNetIPSecLocalIdentifierTypeKeyID
      count += 1
    }

    return [
      keys,
      vals,
      count,
      kCFTypeDictionaryKeyCallBacks,
      kCFTypeDictionaryValueCallBacks
      ] as! CFDictionary
  }

  public var l2TPIPv4Config: CFDictionary {
    var size: Int
    if !enableSplitTunnel {
      size = 2
    } else {
      size = 1
    }

    var keys: [CFString?] = Array(repeating: nil, count: size)
    var vals: [CFString?] = Array(repeating: nil, count: size)
    var count = CFIndex(0)

    keys[count] = kSCPropNetIPv4ConfigMethod
    vals[count] = kSCValNetIPv4ConfigMethodPPP
    count += 1

    if !enableSplitTunnel {
      let splitOne = "1"
      keys[count] = kSCPropNetOverridePrimary
      vals[count] = splitOne as CFString?
      count += 1
    }

    return [
      keys,
      vals,
      count,
      kCFTypeDictionaryKeyCallBacks,
      kCFTypeDictionaryValueCallBacks
      ] as! CFDictionary
  }

  public var ciscoConfig: CFDictionary {
    var size: Int
    if localIdentifier == nil {
      size = 3
    } else {
      size = 5
    }

    var keys: [CFString?] = Array(repeating: nil, count: size)
    var vals: [CFString?] = Array(repeating: nil, count: size)
    var count = CFIndex(0)

    keys[count] = kSCPropNetIPSecAuthenticationMethod
    vals[count] = kSCValNetIPSecAuthenticationMethodSharedSecret
    count += 1

    guard let unwrappedServiceID = serviceID else {
      Log.error("Could not unwrap the ServiceID")
      exit(999)
    }

    keys[count] = kSCPropNetIPSecSharedSecret
    vals[count] = "\(unwrappedServiceID).SS" as CFString?
    count += 1

    keys[count] = kSCPropNetIPSecSharedSecretEncryption
    vals[count] = kSCValNetIPSecSharedSecretEncryptionKeychain
    count += 1

    keys[count] = kSCPropNetPPPCommRemoteAddress
    vals[count] = endpoint as CFString?
    count += 1

    keys[count] = kSCPropNetPPPAuthName
    vals[count] = username as CFString?
    count += 1

    keys[count] = kSCPropNetPPPAuthPassword
    vals[count] = serviceID as CFString?
    count += 1

    keys[count] = kSCPropNetIPSecXAuthPasswordEncryption
    vals[count] = kSCValNetIPSecXAuthPasswordEncryptionKeychain
    count += 1

    if (localIdentifier) != nil {
      Log.debug("Assigning group name \(String(describing: localIdentifier)) to Cisco service config")

      keys[count] = kSCPropNetIPSecLocalIdentifier
      vals[count] = localIdentifier as CFString?
      count += 1

      keys[count] = kSCPropNetIPSecLocalIdentifierType
      vals[count] = kSCValNetIPSecLocalIdentifierTypeKeyID
      count += 1
    }

    return [
      keys,
      vals,
      count,
      kCFTypeDictionaryKeyCallBacks,
      kCFTypeDictionaryValueCallBacks
      ] as! CFDictionary
  }
}

